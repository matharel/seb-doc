{{/*
  Purpose: render a small, recursive content tree for site map / menus / section lists.

  Minimal, working version that preserves your original logic and call surface.

  Calling conventions supported (only these two):
    - {{ partial "content-tree.html" . }}
      (simple: call with the current Page as dot; uses the "default" variant)

    - {{ partial "content-tree.html" (dict
          "context" (.Site.GetPage "/")
          "variant" "list"
          "currentPage" .) }}
      (call with a dict containing the variant name, currentPage and optionnaly a different context)

  Behaviour notes:
    - The partial reads its configuration from .Site.Params.contentTree.<variant>
      falling back to .Site.Params.contentTree.default and then to built-in defaults.
    - Context resolution is intentionally simple:
        * If the caller provided a Page in the dict as "context", that Page is used.
        * Else if the variant is "menu", the tree starts from the site root (/).
        * Else the tree starts from the current page's CurrentSection (if any) or the site root.
    - The caller MUST provide the current page (either by calling with . or passing currentPage = .)
      so the partial can mark the active page.
*/}}

{{ define "subpages" }}

{{ $currentPage := .currentPage }}
{{ $cfg := .cfg }}
{{ $depth := .depth }}
{{ $context := .context }}

{{ with .context.Pages }}{{/* pour ne pas avoir de <ul> vides */}}
<ul>
	{{/* If requested, show a link to the root/context page (minimal output) */}}
	{{ if and (index $cfg "includeRoot") (eq $depth (index $cfg "depth")) }}
	<li>
		{{ if (eq $currentPage $context) }}
		<span aria-current="page" class="active">{{ $context.LinkTitle }}</span>
		{{ else }}
		<a href="{{ $context.RelPermalink }}">{{ $context.LinkTitle }}</a>
		{{ end }}
	</li>
	{{ end }}

	{{ range sort . $cfg.sortBy $cfg.order }}
	<li{{ with .Draft }} class="menu_draft"{{ end }}>
		{{ if $cfg.debug }}{{ .Weight }} - {{ end }}
		{{ if (eq $currentPage .) }}
		<span aria-current="page" class="active">{{ .LinkTitle }}</span>
		{{ else }}
		<a href="{{ .RelPermalink }}">{{ .LinkTitle }}</a>
		{{ end }}
          {{/* recurse if unlimited (0) or depth > 1 */}}
          {{ if or (eq $depth 0) (gt $depth 1) }}
            {{ $nextDepth := 0 }}
            {{ if ne $depth 0 }} {{ $nextDepth = sub $depth 1 }} {{ end }}
            {{ template "subpages" (dict "context" . "currentPage" $currentPage "cfg" $cfg "depth" $nextDepth) }}
          {{ end }}
	</li>
	{{ end }}
</ul>
	{{ end }}
{{ end }}

{{/* --- minimal, clearer invocation logic --- */}}

{{ $site := .Site }}
{{ $variant := "default" }}
{{ $currentPage := "" }}
{{ $cfg := dict "sortBy" "LinkTitle" "order" "asc" "debug" false "depth" 0 }}
{{ $context := "" }}

{{ if not .Site }}
  {{/* dot is a dict with options (variant, currentPage, optional context) */}}
  {{ with .variant }}{{ $variant = . }}{{ end }}
  {{ with .currentPage }}{{ $currentPage = . }}{{ end }}
  {{ with .context }}{{ $context = . }}{{ end }}
  {{/* try to obtain site from provided currentPage if available */}}
  {{ if not $site }}
    {{ with $currentPage }}{{ $site = .Site }}{{ end }}
  {{ end }}
{{ else }}
  {{/* dot is the current Page */}}
  {{ $currentPage = . }}
{{ end }}

{{/* if caller didn't specify a variant and we're called with a Page that has a CurrentSection,
     treat this as the 'list' variant */}}
{{ if and (eq $variant "default") $currentPage }}
  {{ with $currentPage.CurrentSection }}
    {{ $variant = "list" }}
  {{ end }}
{{ end }}

{{ if not $site }}{{ errorf "content-tree partial: site context not available" }}{{ end }}

{{ $siteParams := $site.Params.contentTree | default (dict) }}
{{/* safe default to use without any config, otherwise overrided by config */}}
{{ $defaultCfg := index $siteParams "default" | default (dict "sortBy" "LinkTitle" "order" "asc" "debug" false "depth" 0 "includeroot" false) }}
{{ $variantCfgRaw := index $siteParams $variant | default (dict) }}

{{/* Merge: for each key prefer variant value when present, otherwise fallback to default */}}
{{ $cfg = dict }}


{{ with index $variantCfgRaw "sortBy" }}
  {{ $cfg = merge $cfg (dict "sortBy" .) }}
{{ else }}
  {{ $cfg = merge $cfg (dict "sortBy" (index $defaultCfg "sortBy")) }}
{{ end }}

{{ with index $variantCfgRaw "order" }}
  {{ $cfg = merge $cfg (dict "order" .) }}
{{ else }}
  {{ $cfg = merge $cfg (dict "order" (index $defaultCfg "order")) }}
{{ end }}

{{ if isset $variantCfgRaw "debug" }}
  {{ $cfg = merge $cfg (dict "debug" (index $variantCfgRaw "debug")) }}
{{ else }}
  {{ $cfg = merge $cfg (dict "debug" (index $defaultCfg "debug")) }}
{{ end }}

{{ if isset $variantCfgRaw "depth" }}
  {{ $cfg = merge $cfg (dict "depth" (index $variantCfgRaw "depth")) }}
{{ else }}
  {{ $cfg = merge $cfg (dict "depth" (index $defaultCfg "depth")) }}
{{ end }}

{{ if isset $variantCfgRaw "includeroot" }}{{/* -- with isset variable should be lowecase */}}
  {{ $cfg = merge $cfg (dict "includeRoot" (index $variantCfgRaw "includeRoot")) }}
{{ else }}
  {{ $cfg = merge $cfg (dict "includeRoot" (index $defaultCfg "includeRoot")) }}
{{ end }}

{{/* context resolution: very small, deterministic logic:
     - if caller passed a Page as context, use it
     - else if variant == "menu" use site root
     - else use currentPage.CurrentSection or site root
*/}}

{{ if not $context }}
  {{ if eq $variant "menu" }}
    {{ $context = $site.GetPage "/" }}
  {{ else }}
    {{ with $currentPage }}{{ $context = .CurrentSection }}{{ end }}
    {{ if not $context }}{{ $context = $site.GetPage "/" }}{{ end }}
  {{ end }}
{{ end }}

{{/* invoke recursion using cfg.depth (safe extraction) */}}

{{ template "subpages" (dict
	"context" $context
	"currentPage" $currentPage
	"cfg" $cfg
	"depth" (index $cfg "depth")
) }}
